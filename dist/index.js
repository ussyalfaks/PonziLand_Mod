import*as G from"@dojoengine/torii-client";import*as D from"@dojoengine/torii-client";function S(n,e){if(!n)return[];let t=[],{entityIds:r,...s}=n;return r&&r.length>0&&t.push({HashedKeys:r}),t.push(...N(s,e)),t}function N(n,e){let t=[];return Object.entries(n).forEach(([r,s])=>{s&&typeof s=="object"&&Object.entries(s).forEach(([i,o])=>{let a=`${r}-${i}`;if(Array.isArray(o)){let c=I(a,o);c&&t.push(c)}else if(typeof o=="object"&&o!==null&&"$"in o){let c=o.$.where,d=e[r]?.[i];if(d){let u=U(a,c,d.fieldOrder);u&&t.push(u)}}})}),t}function I(n,e){if(Array.isArray(e)&&e.length===0)return{Keys:{keys:[void 0],pattern_matching:"VariableLen",models:[n]}};if(Array.isArray(e))return{Keys:{keys:e,pattern_matching:"FixedLen",models:[n]}}}function U(n,e,t=[]){if(!e||Object.keys(e).length===0)return{Keys:{keys:Array(t.length).fill(void 0),pattern_matching:"VariableLen",models:[n]}};let r=Array(t.length).fill(void 0);return Object.entries(e).forEach(([s,i])=>{let o=t.indexOf(s);o!==-1&&(i.$is!==void 0&&(r[o]=i.$is.toString()),i.$eq!==void 0&&(r[o]=i.$eq.toString()),i.$neq!==void 0&&(r[o]=i.$neq.toString()),i.$gt!==void 0&&(r[o]=i.$gt.toString()),i.$gte!==void 0&&(r[o]=i.$gte.toString()),i.$lt!==void 0&&(r[o]=i.$lt.toString()),i.$lte!==void 0&&(r[o]=i.$lte.toString()))}),console.log("fieldOrder",r),{Keys:{keys:r,pattern_matching:"VariableLen",models:[n]}}}function k(n,e){let t=[];for(let[r,s]of Object.entries(n))if(r!=="entityIds"&&s&&typeof s=="object"){let i=V(r,s,e);i.length>0&&t.push(...i)}if(t.length>1)return{Composite:{operator:"Or",clauses:t}};if(t.length===1)return t[0]}function V(n,e,t){let r=[];for(let[s,i]of Object.entries(e)){let o=`${n}-${s}`;if(i&&typeof i=="object"&&"$"in i){let a=i.$;if(a&&typeof a=="object"&&"where"in a){let c=a.where;if(c&&typeof c=="object"){for(let[u,g]of Object.entries(c))if(typeof g=="object"&&g!==null&&"$is"in g){let l=S({[n]:{[s]:{$:{where:{[u]:{$is:g.$is}}}}}},t);r.push(...l);let{$is:Q,...$}=g;c[u]=$}let d=w(o,c);d&&("Composite"in d&&d.Composite.operator==="Or"?r.push(...d.Composite.clauses):r.push(d))}}}else r.push({Keys:{keys:[void 0],pattern_matching:"FixedLen",models:[o]}})}return r}function w(n,e){let t={And:"And",Or:"Or"},s=Object.keys(e).find(o=>o in t);if(s){let o=t[s],a=e[s],c=[];for(let d of a){let u=w(n,d);u&&c.push(u)}return c.length===1?c[0]:{Composite:{operator:o,clauses:c}}}let i=[];for(let[o,a]of Object.entries(e))if(typeof a=="object"&&a!==null){let d=Object.keys(a).find(u=>u in t);if(d){let u=t[d],g=a[d],l=[];for(let Q of g){let $=w(n,Q);$&&l.push($)}l.length===1?i.push(l[0]):i.push({Composite:{operator:u,clauses:l}})}else for(let[u,g]of Object.entries(a))i.push({Member:{model:n,member:o,operator:B(u),value:R(g)}})}else i.push({Member:{model:n,member:o,operator:"Eq",value:R(a)}});if(i.length===1)return i[0];if(i.length>1)return{Composite:{operator:"And",clauses:i}}}function R(n){if(typeof n=="number")return{Primitive:{U32:n}};if(typeof n=="boolean")return{Primitive:{Bool:n}};if(typeof n=="bigint")return{Primitive:{Felt252:D.cairoShortStringToFelt(n.toString())}};if(typeof n=="string")return{String:n};throw new Error(`Unsupported primitive type: ${typeof n}`)}function B(n){switch(n){case"$eq":return"Eq";case"$neq":return"Neq";case"$gt":return"Gt";case"$gte":return"Gte";case"$lt":return"Lt";case"$lte":return"Lte";default:throw new Error(`Unsupported operator: ${n}`)}}function h(n,e){let t=[];for(let r in n){let s=n[r],i={entityId:r,models:{}};for(let o in s){let[a,c]=o.split("-");if(!a||!c){e?.logging&&console.warn(`Invalid modelName format: ${o}`);continue}i.models[a]||(i.models[a]={}),i.models[a][c]=F(s[o])}t.push(i),e?.logging&&console.log("Parsed entity:",i)}return e?.logging&&console.log("Parsed result:",t),t}function M(n){switch(n.type){case"primitive":return n.value;case"struct":return F(n.value);case"enum":return n.value.option;case"array":return n.value.map(M);default:return n.value}}function F(n){let e=n instanceof Map?Array.from(n.entries()):Object.entries(n);return Object.fromEntries(e.map(([t,r])=>[t,M(r)]))}async function A(n,e,t,r,s=100,i=0,o){let a=k(e,t),c=i,d=!0,u={};for(;d;){let g={limit:s,offset:c,clause:a,dont_include_hashed_keys:!1};try{let l=await n.getEntities(g);o?.logging&&(console.log("Clause",a,"Query",e),console.log(`Fetched entities at offset ${c}:`,l)),Object.assign(u,l);let Q=h(u);r({data:Q}),Object.keys(l).length<s?d=!1:c+=s}catch(l){throw o?.logging&&console.error("Error fetching entities:",l),r({error:l}),l}}return o?.logging&&console.log("All fetched entities:",u),h(u)}async function L(n,e,t,r,s=100,i=0,o){let a=k(e,t),c=i,d=!0,u={};for(;d;){let g={limit:s,offset:c,clause:a,dont_include_hashed_keys:!1};try{let l=await n.getEventMessages(g,!0);o?.logging&&console.log(`Fetched entities at offset ${c}:`,l),Object.assign(u,l);let Q=h(u);r({data:Q}),Object.keys(l).length<s?d=!1:c+=s}catch(l){throw o?.logging&&console.error("Error fetching entities:",l),r({error:l}),l}}return o?.logging&&console.log("All fetched entities:",u),h(u)}async function q(n,e,t,r,s){return s?.logging&&(console.log("Query:",e),console.log("convertQueryToEntityKeyClauses:",S(e,t))),n.onEntityUpdated(S(e,t),(i,o)=>{try{if(r){let a=h({[i]:o});s?.logging&&(console.log("Converted query to entity key clauses:",S(e,t)),console.log("Parsed entity data:",a)),r({data:a})}}catch(a){r&&(s?.logging&&console.error("Error parsing entity data:",a),r({error:a instanceof Error?a:new Error(String(a))}))}})}async function _(n,e,t,r,s){return n.onEventMessageUpdated(S(e,t),!0,(i,o)=>{try{if(r){let a=h({[i]:o});s?.logging&&console.log("Parsed entity data:",a),r({data:a})}}catch(a){r&&(s?.logging&&console.error("Error parsing entity data:",a),r({error:a instanceof Error?a:new Error(String(a))}))}})}import{writable as W,get as P,derived as H}from"svelte/store";import{produce as v,produceWithPatches as J,applyPatches as X}from"immer";function Ee(){let e=W({entities:{},pendingTransactions:{}}),{subscribe:t,set:r,update:s}=e,i=y=>{s(f=>v(f,p=>{y.forEach(T=>{p.entities[T.entityId]=T})}))},o=y=>{s(f=>v(f,p=>{if(y.entityId&&p.entities[y.entityId]&&y.models){let T=p.entities[y.entityId],m=Object.assign({},T.models);Object.entries(y.models).forEach(([b,C])=>{let E=b;E in m||(m[E]={}),m[E]=Object.assign({},m[E],C)}),p.entities[y.entityId]={...T,...y,models:m}}}))},a=(y,f)=>{let p=P(e),[T,m,b]=J(p,C=>{f(C)});r(T),s(C=>v(C,E=>{E.pendingTransactions[y]={transactionId:y,patches:m,inversePatches:b}}))},c=y=>{let f=P(e),p=f.pendingTransactions[y];if(p){let T=X(f,p.inversePatches);r(T),s(m=>v(m,b=>{delete b.pendingTransactions[y]}))}},d=y=>{s(f=>v(f,p=>{delete p.pendingTransactions[y]}))},u=y=>P(e).entities[y],g=y=>{let f=P(e),p=Object.values(f.entities);return y?p.filter(y):p};return{subscribe:t,setEntities:i,updateEntity:o,applyOptimisticUpdate:a,revertOptimisticUpdate:c,confirmTransaction:d,subscribeToEntity:(y,f)=>H(e,T=>T.entities[y]).subscribe(f),waitForEntityChange:(y,f,p=6e3)=>new Promise((T,m)=>{let b=t(E=>{let j=E.entities[y];f(j)&&(clearTimeout(C),b(),T(j))}),C=setTimeout(()=>{b(),m(new Error(`waitForEntityChange: Timeout of ${p}ms exceeded`))},p)}),getEntity:u,getEntities:g,getEntitiesByModel:(y,f)=>g(p=>!!p.models[y]?.[f])}}var z=class{namespaces;constructor(){this.namespaces=new Map}namespace(e,t){let r=new O(this);return this.namespaces.set(e,r),t(r),r}build(){let e={};for(let[t,r]of this.namespaces){e[t]={};for(let[s,i]of r.entities){let o={};for(let[a,c]of i.constraints)o[a]={[`${c.operator}`]:c.value};e[t][s]={$:{where:{...e[t]?.[s]?.$?.where??{},...o}}}}}return e}},O=class{constructor(e){this.parent=e;this.entities=new Map}entities;entity(e,t){let r=new x(this);return this.entities.set(e,r),t(r),r}namespace(e,t){return this.parent.namespace(e,t)}build(){return this.parent.build()}},x=class{constructor(e){this.parent=e;this.constraints=new Map}constraints;entity(e,t){return this.parent.entity(e,t)}is(e,t){return this.addConstraint(e,t,"$is")}eq(e,t){return this.addConstraint(e,t,"$eq")}neq(e,t){return this.addConstraint(e,t,"$neq")}gt(e,t){return this.addConstraint(e,t,"$gt")}gte(e,t){return this.addConstraint(e,t,"$gte")}lt(e,t){return this.addConstraint(e,t,"$lt")}lte(e,t){return this.addConstraint(e,t,"$lte")}addConstraint(e,t,r){return this.constraints.set(e,new K(r,t)),this}build(){return this.parent.build()}},K=class{constructor(e,t){this._operator=e;this._value=t}get operator(){return this._operator.toString()}get value(){return this._value}};async function Y(n){return await G.createClient(n)}async function Oe(n,e){let t=await Y(n.client);return{client:t,subscribeEntityQuery:({query:r,callback:s,options:i})=>q(t,r,e,s,i),subscribeEventQuery:({query:r,callback:s,options:i})=>_(t,r,e,s,i),getEntities:({query:r,callback:s,limit:i,offset:o,options:a})=>A(t,r,e,s,i,o,a),getEventMessages:({query:r,callback:s,limit:i,offset:o,options:a})=>L(t,r,e,s,i,o,a),generateTypedData:(r,s,i=n.domain)=>({types:{StarknetDomain:[{name:"name",type:"shortstring"},{name:"version",type:"shortstring"},{name:"chainId",type:"shortstring"},{name:"revision",type:"shortstring"}],[r]:Object.keys(s).map(o=>({name:o,type:typeof s[o]=="bigint"||typeof s[o]=="number"?"felt":"string"}))},primaryType:r,domain:i,message:s}),sendMessage:async(r,s,i=!1)=>{try{let o=await s.signMessage(r),a=JSON.stringify(r);await t.publishMessage(a,Array.isArray(o)?o:[o.r.toString(),o.s.toString()],i)}catch(o){throw console.error("Failed to send message:",o),o}},getTokens:async r=>await t.getTokens(r),getTokenBalances:async(r,s)=>await t.getTokenBalances(r,s)}}export{z as QueryBuilder,Y as createClient,Ee as createDojoStore,Oe as init};
//# sourceMappingURL=index.js.map