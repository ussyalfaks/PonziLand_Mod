{"version":3,"sources":["../src/index.ts","../src/convertQuerytoClause.ts","../src/convertQueryToEntityKeyClauses.ts","../src/parseEntities.ts","../src/getEntities.ts","../src/getEventMessages.ts","../src/subscribeEntityQuery.ts","../src/subscribeEventQuery.ts","../src/state/svelte.ts","../src/queryBuilder.ts"],"sourcesContent":["import * as torii from \"@dojoengine/torii-client\";\nimport { Account, Signature, StarknetDomain, TypedData } from \"starknet\";\n\nimport { getEntities } from \"./getEntities\";\nimport { getEventMessages } from \"./getEventMessages\";\nimport { subscribeEntityQuery } from \"./subscribeEntityQuery\";\nimport { subscribeEventQuery } from \"./subscribeEventQuery\";\nimport { SchemaType, SDK, SDKConfig, UnionOfModelData } from \"./types\";\n\nexport * from \"./types\";\nexport * from \"./state\";\nexport * from \"./queryBuilder\";\n\n/**\n * Creates a new Torii client instance.\n *\n * @param {torii.ClientConfig} config - The configuration object for the Torii client.\n * @returns {Promise<torii.ToriiClient>} - A promise that resolves to the Torii client instance.\n */\nexport async function createClient(\n    config: torii.ClientConfig\n): Promise<torii.ToriiClient> {\n    return await torii.createClient(config);\n}\n\n/**\n * Initializes the SDK with the provided configuration and schema.\n *\n * @template T - The schema type.\n * @param {torii.ClientConfig} options - The configuration object for the Torii client.\n * @param {T} schema - The schema object defining the structure of the data.\n * @returns {Promise<SDK<T>>} - A promise that resolves to the initialized SDK.\n */\nexport async function init<T extends SchemaType>(\n    options: SDKConfig,\n    schema: T\n): Promise<SDK<T>> {\n    const client = await createClient(options.client);\n\n    return {\n        client,\n        /**\n         * Subscribes to entity queries.\n         *\n         * @param {SubscribeParams<T>} params - Parameters object\n         * @returns {Promise<void>} - A promise that resolves when the subscription is set up.\n         */\n        subscribeEntityQuery: ({ query, callback, options }) =>\n            subscribeEntityQuery(client, query, schema, callback, options),\n        /**\n         * Subscribes to event queries.\n         *\n         * @param {SubscribeParams<T>} params - Parameters object\n         * @returns {Promise<void>} - A promise that resolves when the subscription is set up.\n         */\n        subscribeEventQuery: ({ query, callback, options }) =>\n            subscribeEventQuery(client, query, schema, callback, options),\n        /**\n         * Fetches entities based on the provided query.\n         *\n         * @param {GetParams<T>} params - Parameters object\n         * @returns {Promise<StandardizedQueryResult<T>>} - A promise that resolves to the standardized query result.\n         */\n        getEntities: ({ query, callback, limit, offset, options }) =>\n            getEntities(\n                client,\n                query,\n                schema,\n                callback,\n                limit,\n                offset,\n                options\n            ),\n        /**\n         * Fetches event messages based on the provided query.\n         *\n         * @param {GetParams<T>} params - Parameters object\n         * @returns {Promise<StandardizedQueryResult<T>>} - A promise that resolves to the standardized query result.\n         */\n        getEventMessages: ({ query, callback, limit, offset, options }) =>\n            getEventMessages(\n                client,\n                query,\n                schema,\n                callback,\n                limit,\n                offset,\n                options\n            ),\n\n        /**\n         * Generates typed data for any user-defined message.\n         *\n         * @template M - The message type defined by the schema models.\n         * @param {string} primaryType - The primary type of the message.\n         * @param {M} message - The user-defined message content, must be part of the schema models.\n         * @param {StarknetDomain} [domain] - The domain object. If not provided, uses the default domain from options.\n         * @returns {TypedData} - The generated typed data.\n         */\n        generateTypedData: <M extends UnionOfModelData<T>>(\n            primaryType: string,\n            message: M,\n            domain: StarknetDomain = options.domain\n        ): TypedData => ({\n            types: {\n                StarknetDomain: [\n                    { name: \"name\", type: \"shortstring\" },\n                    { name: \"version\", type: \"shortstring\" },\n                    { name: \"chainId\", type: \"shortstring\" },\n                    { name: \"revision\", type: \"shortstring\" },\n                ],\n                [primaryType]: Object.keys(message).map((key) => ({\n                    name: key,\n                    type:\n                        typeof message[key] === \"bigint\" ||\n                        typeof message[key] === \"number\"\n                            ? \"felt\"\n                            : \"string\",\n                })),\n            },\n            primaryType,\n            domain,\n            message,\n        }),\n\n        /**\n         * Sends a signed message.\n         *\n         * @param {TypedData} data - The typed data to be signed and sent.\n         * @param {Account} account - The account used to sign the message.\n         * @param {boolean} [isSessionSignature=false] - Whether the signature is a session signature.\n         * @returns {Promise<void>} - A promise that resolves when the message is sent successfully.\n         * @throws {Error} If the message sending fails.\n         */\n        sendMessage: async (\n            data: TypedData,\n            account: Account,\n            isSessionSignature: boolean = false\n        ): Promise<void> => {\n            try {\n                // Sign the typed data\n                const signature: Signature = await account.signMessage(data);\n\n                // Stringify typed data for publishing\n                const dataString = JSON.stringify(data);\n                // Publish the signed message\n                await client.publishMessage(\n                    dataString,\n                    Array.isArray(signature)\n                        ? signature\n                        : [signature.r.toString(), signature.s.toString()],\n                    isSessionSignature\n                );\n            } catch (error) {\n                console.error(\"Failed to send message:\", error);\n                throw error;\n            }\n        },\n\n        /**\n         * @param {(string)[]} contract_addresses\n         * @returns {Promise<Tokens>}\n         */\n        getTokens: async (\n            contract_addresses: string[]\n        ): Promise<torii.Tokens> => {\n            return await client.getTokens(contract_addresses);\n        },\n\n        /**\n         * @param {(string)[]} account_addresses\n         * @param {(string)[]} contract_addresses\n         * @returns {Promise<TokenBalances>}\n         */\n        getTokenBalances: async (\n            account_addresses: string[],\n            contract_addresses: string[]\n        ): Promise<torii.TokenBalances> => {\n            return await client.getTokenBalances(\n                account_addresses,\n                contract_addresses\n            );\n        },\n    };\n}\n","// packages/sdk/src/convertQuerytoClause.ts\n\nimport * as torii from \"@dojoengine/torii-client\";\nimport { QueryType, SchemaType, SubscriptionQueryType } from \"./types\";\nimport { convertQueryToEntityKeyClauses } from \"./convertQueryToEntityKeyClauses\";\n\n/**\n * Converts a query object into a Torii clause.\n *\n * @template T - The schema type.\n * @param {QueryType<T>} query - The query object to convert.\n * @param {T} schema - The schema providing field order information.\n * @returns {torii.Clause | undefined} - The resulting Torii clause or undefined.\n */\nexport function convertQueryToClause<T extends SchemaType>(\n    query: QueryType<T>,\n    schema: T\n): torii.Clause | undefined {\n    const clauses: torii.Clause[] = [];\n\n    for (const [namespace, models] of Object.entries(query)) {\n        if (namespace === \"entityIds\") continue; // Skip entityIds\n\n        if (models && typeof models === \"object\") {\n            const modelClauses = processModels(namespace, models, schema);\n            if (modelClauses.length > 0) {\n                clauses.push(...modelClauses);\n            }\n        }\n    }\n\n    // If there are clauses, combine them under a single Composite clause\n    if (clauses.length > 1) {\n        return {\n            Composite: {\n                operator: \"Or\",\n                clauses: clauses,\n            },\n        };\n    } else if (clauses.length === 1) {\n        return clauses[0];\n    }\n\n    // If there are no clauses, return undefined\n    return undefined;\n}\n\n/**\n * Processes all models within a namespace and generates corresponding clauses.\n *\n * @template T - The schema type.\n * @param {string} namespace - The namespace of the models.\n * @param {any} models - The models object to process.\n * @param {T} schema - The schema providing field order information.\n * @returns {torii.Clause[]} - An array of generated clauses.\n */\nfunction processModels<T extends SchemaType>(\n    namespace: string,\n    models: any,\n    schema: T\n): torii.Clause[] {\n    const clauses: torii.Clause[] = [];\n\n    for (const [model, modelData] of Object.entries(models)) {\n        const namespaceModel = `${namespace}-${model}`;\n\n        if (modelData && typeof modelData === \"object\" && \"$\" in modelData) {\n            const conditions = modelData.$ as Record<string, unknown>;\n            if (\n                conditions &&\n                typeof conditions === \"object\" &&\n                \"where\" in conditions\n            ) {\n                const whereClause = conditions.where;\n                if (whereClause && typeof whereClause === \"object\") {\n                    // Iterate over each member in the whereClause to handle $is\n                    for (const [member, memberConditions] of Object.entries(\n                        whereClause\n                    )) {\n                        if (\n                            typeof memberConditions === \"object\" &&\n                            memberConditions !== null &&\n                            \"$is\" in memberConditions\n                        ) {\n                            // Convert $is to EntityKeysClause\n                            const isClauses = convertQueryToEntityKeyClauses(\n                                {\n                                    [namespace]: {\n                                        [model]: {\n                                            $: {\n                                                where: {\n                                                    [member]: {\n                                                        $is: memberConditions[\n                                                            \"$is\"\n                                                        ],\n                                                    },\n                                                },\n                                            },\n                                        },\n                                    },\n                                } as SubscriptionQueryType<T>,\n                                schema\n                            );\n                            clauses.push(...(isClauses as any));\n\n                            // Remove $is from memberConditions to prevent further processing\n                            const { $is, ...remainingConditions } =\n                                memberConditions;\n                            (whereClause as Record<string, unknown>)[member] =\n                                remainingConditions;\n                        }\n                    }\n\n                    // After handling all $is, build the remaining whereClause\n                    const clause = buildWhereClause(\n                        namespaceModel,\n                        whereClause\n                    );\n                    if (clause) {\n                        if (\n                            \"Composite\" in clause &&\n                            clause.Composite.operator === \"Or\"\n                        ) {\n                            // If the composite operator is \"Or\", flatten the clauses\n                            clauses.push(...clause.Composite.clauses);\n                        } else {\n                            // Otherwise, keep the composite as is to preserve logical structure\n                            clauses.push(clause);\n                        }\n                    }\n                }\n            }\n        } else {\n            // Handle the case where there are no conditions\n            clauses.push({\n                Keys: {\n                    keys: [undefined],\n                    pattern_matching: \"FixedLen\",\n                    models: [namespaceModel],\n                },\n            });\n        }\n    }\n\n    return clauses;\n}\n\n/**\n * Builds a Torii clause from a where clause object.\n *\n * @param {string} namespaceModel - The namespaced model identifier.\n * @param {Record<string, any>} where - The where clause conditions.\n * @returns {torii.Clause | undefined} - The constructed Torii clause or undefined.\n */\nfunction buildWhereClause(\n    namespaceModel: string,\n    where: Record<string, any>\n): torii.Clause | undefined {\n    // Define logical operator mapping\n    const logicalOperators: Record<string, torii.LogicalOperator> = {\n        And: \"And\",\n        Or: \"Or\",\n    };\n\n    // Check for logical operators first\n    const keys = Object.keys(where);\n    const logicalKey = keys.find((key) => key in logicalOperators);\n\n    if (logicalKey) {\n        const operator = logicalOperators[logicalKey];\n        const conditions = where[logicalKey] as Array<Record<string, any>>;\n\n        const subClauses: torii.Clause[] = [];\n\n        for (const condition of conditions) {\n            const clause = buildWhereClause(namespaceModel, condition);\n            if (clause) {\n                subClauses.push(clause);\n            }\n        }\n\n        if (subClauses.length === 1) {\n            return subClauses[0];\n        }\n\n        return {\n            Composite: {\n                operator: operator,\n                clauses: subClauses,\n            },\n        };\n    }\n\n    // If no logical operator, build Member clauses\n    const memberClauses: torii.Clause[] = [];\n\n    for (const [member, memberValue] of Object.entries(where)) {\n        if (typeof memberValue === \"object\" && memberValue !== null) {\n            const memberKeys = Object.keys(memberValue);\n            // Check if memberValue contains logical operators\n            const memberLogicalKey = memberKeys.find(\n                (key) => key in logicalOperators\n            );\n            if (memberLogicalKey) {\n                const operator = logicalOperators[memberLogicalKey];\n                const conditions = memberValue[memberLogicalKey] as Array<\n                    Record<string, any>\n                >;\n\n                const nestedClauses: torii.Clause[] = [];\n                for (const condition of conditions) {\n                    const clause = buildWhereClause(namespaceModel, condition);\n                    if (clause) {\n                        nestedClauses.push(clause);\n                    }\n                }\n\n                if (nestedClauses.length === 1) {\n                    memberClauses.push(nestedClauses[0]);\n                } else {\n                    memberClauses.push({\n                        Composite: {\n                            operator: operator,\n                            clauses: nestedClauses,\n                        },\n                    });\n                }\n            } else {\n                // Process operators like $eq, $gt, etc\n                for (const [op, val] of Object.entries(memberValue)) {\n                    memberClauses.push({\n                        Member: {\n                            model: namespaceModel,\n                            member,\n                            operator: convertOperator(op),\n                            value: convertToPrimitive(val),\n                        },\n                    });\n                }\n            }\n        } else {\n            // Assume equality condition\n            memberClauses.push({\n                Member: {\n                    model: namespaceModel,\n                    member,\n                    operator: \"Eq\",\n                    value: convertToPrimitive(memberValue),\n                },\n            });\n        }\n    }\n\n    if (memberClauses.length === 1) {\n        return memberClauses[0];\n    } else if (memberClauses.length > 1) {\n        return {\n            // conditions in member clause should be treated as \"And\" Conditions by default\n            Composite: {\n                operator: \"And\",\n                clauses: memberClauses,\n            },\n        };\n    }\n\n    return undefined;\n}\n\n/**\n * Converts a value to a Torii primitive type.\n *\n * @param {any} value - The value to convert.\n * @returns {torii.MemberValue} - The converted primitive value.\n * @throws {Error} - If the value type is unsupported.\n */\nfunction convertToPrimitive(value: any): torii.MemberValue {\n    if (typeof value === \"number\") {\n        return { Primitive: { U32: value } };\n    } else if (typeof value === \"boolean\") {\n        return { Primitive: { Bool: value } };\n    } else if (typeof value === \"bigint\") {\n        return {\n            Primitive: {\n                Felt252: torii.cairoShortStringToFelt(value.toString()),\n            },\n        };\n    } else if (typeof value === \"string\") {\n        return { String: value };\n    }\n\n    // Add more type conversions as needed\n    throw new Error(`Unsupported primitive type: ${typeof value}`);\n}\n\n/**\n * Converts a query operator to a Torii comparison operator.\n *\n * @param {string} operator - The query operator to convert.\n * @returns {torii.ComparisonOperator} - The corresponding Torii comparison operator.\n * @throws {Error} - If the operator is unsupported.\n */\nfunction convertOperator(operator: string): torii.ComparisonOperator {\n    switch (operator) {\n        case \"$eq\":\n            return \"Eq\";\n        case \"$neq\":\n            return \"Neq\";\n        case \"$gt\":\n            return \"Gt\";\n        case \"$gte\":\n            return \"Gte\";\n        case \"$lt\":\n            return \"Lt\";\n        case \"$lte\":\n            return \"Lte\";\n        default:\n            throw new Error(`Unsupported operator: ${operator}`);\n    }\n}\n","import * as torii from \"@dojoengine/torii-client\";\n\nimport { SchemaType, SubscriptionQueryType } from \"./types\";\n\n/**\n * Converts a subscription query to an array of EntityKeysClause.\n *\n * @template T - The schema type.\n * @param {SubscriptionQueryType<T>} query - The subscription query to convert.\n * @param {T} schema - The schema providing field order information.\n * @returns {torii.EntityKeysClause[]} An array of EntityKeysClause.\n */\nexport function convertQueryToEntityKeyClauses<T extends SchemaType>(\n    query: SubscriptionQueryType<T>,\n    schema: T\n): torii.EntityKeysClause[] {\n    if (!query) {\n        return [];\n    }\n\n    const clauses: torii.EntityKeysClause[] = [];\n\n    const { entityIds, ...namespaces } = query;\n\n    if (entityIds && entityIds.length > 0) {\n        clauses.push({ HashedKeys: entityIds });\n    }\n\n    clauses.push(...convertQueryToKeysClause(namespaces, schema));\n\n    return clauses;\n}\n\n/**\n * Converts namespaces to an array of EntityKeysClause.\n *\n * @template T - The schema type.\n * @param {Omit<SubscriptionQueryType<T>, \"entityIds\">} namespaces - The namespaces to convert.\n * @param {T} schema - The schema providing field order information.\n * @returns {torii.EntityKeysClause[]} An array of EntityKeysClause.\n */\nexport function convertQueryToKeysClause<T extends SchemaType>(\n    namespaces: Omit<SubscriptionQueryType<T>, \"entityIds\">,\n    schema: T\n): torii.EntityKeysClause[] {\n    const clauses: torii.EntityKeysClause[] = [];\n\n    Object.entries(namespaces).forEach(([namespace, models]) => {\n        if (models && typeof models === \"object\") {\n            Object.entries(models).forEach(([model, value]) => {\n                const namespaceModel = `${namespace}-${model}`;\n                if (Array.isArray(value)) {\n                    const clause = createClause(namespaceModel, value);\n                    if (clause) {\n                        clauses.push(clause);\n                    }\n                } else if (\n                    typeof value === \"object\" &&\n                    value !== null &&\n                    \"$\" in value\n                ) {\n                    const whereOptions = (value as { $: { where: any } }).$\n                        .where;\n                    const modelSchema = schema[namespace]?.[model];\n                    if (modelSchema) {\n                        const clause = createClauseFromWhere(\n                            namespaceModel,\n                            whereOptions,\n                            modelSchema.fieldOrder\n                        );\n                        if (clause) {\n                            clauses.push(clause);\n                        }\n                    }\n                }\n            });\n        }\n    });\n\n    return clauses;\n}\n\n/**\n * Creates an EntityKeysClause based on the provided model and value.\n *\n * @param {string} namespaceModel - The combined namespace and model string.\n * @param {string[]} value - The value associated with the model.\n * @returns {torii.EntityKeysClause | undefined} An EntityKeysClause or undefined.\n */\nfunction createClause(\n    namespaceModel: string,\n    value: string[]\n): torii.EntityKeysClause | undefined {\n    if (Array.isArray(value) && value.length === 0) {\n        return {\n            Keys: {\n                keys: [undefined],\n                pattern_matching: \"VariableLen\",\n                models: [namespaceModel],\n            },\n        };\n    } else if (Array.isArray(value)) {\n        return {\n            Keys: {\n                keys: value,\n                pattern_matching: \"FixedLen\",\n                models: [namespaceModel],\n            },\n        };\n    }\n    return undefined;\n}\n\n/**\n * Creates an EntityKeysClause based on the provided where conditions.\n * Orders the keys array based on the fieldOrder from the schema,\n * inserting undefined placeholders where necessary.\n *\n * @param {string} namespaceModel - The combined namespace and model string.\n * @param {Record<string, { $is?: any; $eq?: any; $neq?: any; $gt?: any; $gte?: any; $lt?: any; $lte?: any }>} [whereOptions] - The where conditions from the query.\n * @param {string[]} [fieldOrder=[]] - The defined order of fields for the model.\n * @returns {torii.EntityKeysClause | undefined} An EntityKeysClause or undefined.\n */\nfunction createClauseFromWhere(\n    namespaceModel: string,\n    whereOptions?: Record<\n        string,\n        {\n            $is?: any;\n            $eq?: any;\n            $neq?: any;\n            $gt?: any;\n            $gte?: any;\n            $lt?: any;\n            $lte?: any;\n        }\n    >,\n    fieldOrder: string[] = []\n): torii.EntityKeysClause | undefined {\n    if (!whereOptions || Object.keys(whereOptions).length === 0) {\n        return {\n            Keys: {\n                keys: Array(fieldOrder.length).fill(undefined),\n                pattern_matching: \"VariableLen\",\n                models: [namespaceModel],\n            },\n        };\n    }\n\n    // Initialize keys array with undefined placeholders\n    const keys: (string | undefined)[] = Array(fieldOrder.length).fill(\n        undefined\n    );\n\n    Object.entries(whereOptions).forEach(([field, condition]) => {\n        // Find the index of the field in the fieldOrder\n        const index = fieldOrder.indexOf(field);\n        if (index !== -1) {\n            // Assign value without operator prefixes\n            if (condition.$is !== undefined) {\n                keys[index] = condition.$is.toString();\n            }\n            if (condition.$eq !== undefined) {\n                keys[index] = condition.$eq.toString();\n            }\n            if (condition.$neq !== undefined) {\n                keys[index] = condition.$neq.toString();\n            }\n            if (condition.$gt !== undefined) {\n                keys[index] = condition.$gt.toString();\n            }\n            if (condition.$gte !== undefined) {\n                keys[index] = condition.$gte.toString();\n            }\n            if (condition.$lt !== undefined) {\n                keys[index] = condition.$lt.toString();\n            }\n            if (condition.$lte !== undefined) {\n                keys[index] = condition.$lte.toString();\n            }\n            // Add more operators as needed\n        }\n    });\n\n    console.log(\"fieldOrder\", keys);\n\n    return {\n        Keys: {\n            keys: keys,\n            pattern_matching: \"VariableLen\",\n            models: [namespaceModel],\n        },\n    };\n}\n","import * as torii from \"@dojoengine/torii-client\";\n\nimport { ParsedEntity, SchemaType, StandardizedQueryResult } from \"./types\";\n\n/**\n * Parses a collection of entities into a standardized query result format.\n *\n * @template T - The schema type.\n * @param {torii.Entities} entities - The collection of entities to parse.\n * @param {{ logging?: boolean }} [options] - Optional settings for logging.\n * @returns {StandardizedQueryResult<T>} - The parsed entities in a standardized query result format.\n *\n * @example\n * const parsedResult = parseEntities(entities, { logging: true });\n * console.log(parsedResult);\n */\nexport function parseEntities<T extends SchemaType>(\n    entities: torii.Entities,\n    options?: { logging?: boolean }\n): StandardizedQueryResult<T> {\n    const result: StandardizedQueryResult<T> = [];\n\n    for (const entityId in entities) {\n        const entityData = entities[entityId];\n        const parsedEntity: ParsedEntity<T> = {\n            entityId,\n            models: {} as ParsedEntity<T>[\"models\"],\n        };\n\n        for (const modelName in entityData) {\n            const [schemaKey, modelKey] = modelName.split(\"-\") as [\n                keyof T,\n                string,\n            ];\n\n            if (!schemaKey || !modelKey) {\n                if (options?.logging) {\n                    console.warn(`Invalid modelName format: ${modelName}`);\n                }\n                continue;\n            }\n\n            if (!parsedEntity.models[schemaKey]) {\n                parsedEntity.models[schemaKey] = {} as T[typeof schemaKey];\n            }\n\n            (parsedEntity.models[schemaKey] as any)[modelKey] = parseStruct(\n                entityData[modelName]\n            );\n        }\n\n        result.push(parsedEntity);\n\n        if (options?.logging) {\n            console.log(`Parsed entity:`, parsedEntity);\n        }\n    }\n\n    if (options?.logging) {\n        console.log(\"Parsed result:\", result);\n    }\n\n    return result;\n}\n\n/**\n * Parses a value based on its type.\n *\n * @param {torii.Ty} value - The value to parse.\n * @returns {any} - The parsed value.\n */\nfunction parseValue(value: torii.Ty): any {\n    switch (value.type) {\n        case \"primitive\":\n            return value.value;\n        case \"struct\":\n            return parseStruct(\n                value.value as Record<string, torii.Ty> | Map<string, torii.Ty>\n            );\n        case \"enum\":\n            return (value.value as torii.EnumValue).option;\n        case \"array\":\n            return (value.value as torii.Ty[]).map(parseValue);\n        default:\n            return value.value;\n    }\n}\n\n/**\n * Parses a struct (record or map) into an object with parsed values.\n *\n * @param {Record<string, torii.Ty> | Map<string, torii.Ty>} struct - The struct to parse.\n * @returns {any} - The parsed struct as an object.\n */\nfunction parseStruct(\n    struct: Record<string, torii.Ty> | Map<string, torii.Ty>\n): any {\n    const entries =\n        struct instanceof Map\n            ? Array.from(struct.entries())\n            : Object.entries(struct);\n    return Object.fromEntries(\n        entries.map(([key, value]) => [key, parseValue(value)])\n    );\n}\n","import * as torii from \"@dojoengine/torii-client\";\n\nimport { convertQueryToClause } from \"./convertQuerytoClause\";\nimport { parseEntities } from \"./parseEntities\";\nimport { QueryType, SchemaType, StandardizedQueryResult } from \"./types\";\n\n/**\n * Fetches entities from the Torii client based on the provided query.\n *\n * @template T - The schema type.\n * @param {torii.ToriiClient} client - The Torii client instance used to fetch entities.\n * @param {QueryType<T>} query - The query object used to filter entities.\n * @param {(response: { data?: StandardizedQueryResult<T>; error?: Error }) => void} callback - The callback function to handle the response.\n * @param {number} [limit=100] - The maximum number of entities to fetch per request. Default is 100.\n * @param {number} [offset=0] - The offset to start fetching entities from. Default is 0.\n * @param {{ logging?: boolean }} [options] - Optional settings.\n * @param {boolean} [options.logging] - If true, enables logging of the fetching process. Default is false.\n * @returns {Promise<StandardizedQueryResult<T>>} - A promise that resolves to the standardized query result.\n *\n * @example\n * const result = await getEntities(client, query, (response) => {\n *     if (response.error) {\n *         console.error(\"Error:\", response.error);\n *     } else {\n *         console.log(\"Data:\", response.data);\n *     }\n * }, 100, 0, { logging: true });\n */\nexport async function getEntities<T extends SchemaType>(\n    client: torii.ToriiClient,\n    query: QueryType<T>,\n    schema: T,\n    callback: (response: {\n        data?: StandardizedQueryResult<T>;\n        error?: Error;\n    }) => void,\n    limit: number = 100, // Default limit\n    offset: number = 0, // Default offset\n    options?: { logging?: boolean } // Logging option\n): Promise<StandardizedQueryResult<T>> {\n    const clause = convertQueryToClause(query, schema);\n\n    let cursor = offset;\n    let continueFetching = true;\n    let allEntities: torii.Entities = {};\n\n    while (continueFetching) {\n        const toriiQuery: torii.Query = {\n            limit: limit,\n            offset: cursor,\n            clause,\n            dont_include_hashed_keys: false,\n        };\n\n        try {\n            const entities = await client.getEntities(toriiQuery);\n\n            if (options?.logging) {\n                console.log(\"Clause\", clause, \"Query\", query);\n                console.log(`Fetched entities at offset ${cursor}:`, entities);\n            }\n\n            Object.assign(allEntities, entities);\n\n            const parsedEntities = parseEntities<T>(allEntities);\n\n            callback({ data: parsedEntities });\n\n            if (Object.keys(entities).length < limit) {\n                continueFetching = false;\n            } else {\n                cursor += limit;\n            }\n        } catch (error) {\n            if (options?.logging) {\n                console.error(\"Error fetching entities:\", error);\n            }\n            callback({ error: error as Error });\n            throw error;\n        }\n    }\n\n    if (options?.logging) {\n        console.log(\"All fetched entities:\", allEntities);\n    }\n    return parseEntities<T>(allEntities);\n}\n","import * as torii from \"@dojoengine/torii-client\";\n\nimport { convertQueryToClause } from \"./convertQuerytoClause\";\nimport { parseEntities } from \"./parseEntities\";\nimport { QueryType, SchemaType, StandardizedQueryResult } from \"./types\";\n\n/**\n * Fetches event messages from the Torii client based on the provided query.\n *\n * @template T - The schema type.\n * @param {torii.ToriiClient} client - The Torii client instance used to fetch event messages.\n * @param {QueryType<T>} query - The query object used to filter event messages.\n * @param {T} schema - The schema type for the entities.\n * @param {(response: { data?: StandardizedQueryResult<T>; error?: Error }) => void} callback - The callback function to handle the response.\n * @param {number} [limit=100] - The maximum number of event messages to fetch per request. Default is 100.\n * @param {number} [offset=0] - The offset to start fetching event messages from. Default is 0.\n * @param {{ logging?: boolean }} [options] - Optional settings.\n * @returns {Promise<StandardizedQueryResult<T>>} - A promise that resolves to the standardized query result.\n *\n * @example\n * const eventMessages = await getEventMessages(client, query, schema, (response) => {\n *     if (response.error) {\n *         console.error(\"Error:\", response.error);\n *     } else {\n *         console.log(\"Data:\", response.data);\n *     }\n * }, 100, 0, { logging: true });\n */\nexport async function getEventMessages<T extends SchemaType>(\n    client: torii.ToriiClient,\n    query: QueryType<T>,\n    schema: T,\n    callback: (response: {\n        data?: StandardizedQueryResult<T>;\n        error?: Error;\n    }) => void,\n    limit: number = 100, // Default limit\n    offset: number = 0, // Default offset\n    options?: { logging?: boolean } // Logging option\n): Promise<StandardizedQueryResult<T>> {\n    const clause = convertQueryToClause(query, schema);\n\n    let cursor = offset;\n    let continueFetching = true;\n    let allEntities: torii.Entities = {};\n\n    while (continueFetching) {\n        const toriiQuery: torii.Query = {\n            limit: limit,\n            offset: cursor,\n            clause,\n            dont_include_hashed_keys: false,\n        };\n\n        try {\n            const entities = await client.getEventMessages(toriiQuery, true);\n\n            if (options?.logging) {\n                console.log(`Fetched entities at offset ${cursor}:`, entities);\n            }\n\n            Object.assign(allEntities, entities);\n\n            const parsedEntities = parseEntities<T>(allEntities);\n\n            callback({ data: parsedEntities });\n\n            if (Object.keys(entities).length < limit) {\n                continueFetching = false;\n            } else {\n                cursor += limit;\n            }\n        } catch (error) {\n            if (options?.logging) {\n                console.error(\"Error fetching entities:\", error);\n            }\n            callback({ error: error as Error });\n            throw error;\n        }\n    }\n\n    if (options?.logging) {\n        console.log(\"All fetched entities:\", allEntities);\n    }\n    return parseEntities<T>(allEntities);\n}\n","import * as torii from \"@dojoengine/torii-client\";\n\nimport { convertQueryToEntityKeyClauses } from \"./convertQueryToEntityKeyClauses\";\nimport { parseEntities } from \"./parseEntities\";\nimport {\n    SchemaType,\n    StandardizedQueryResult,\n    SubscriptionQueryType,\n} from \"./types\";\n\n/**\n * Subscribes to entity updates based on the provided query and invokes the callback with the updated data.\n *\n * @template T - The schema type.\n * @param {torii.ToriiClient} client - The Torii client instance.\n * @param {SubscriptionQueryType<T>} query - The subscription query to filter the entities.\n * @param {T} schema - The schema type for the entities.\n * @param {(response: { data?: StandardizedQueryResult<T>; error?: Error }) => void} [callback] - The callback function to handle the response.\n * @param {{ logging?: boolean }} [options] - Optional settings for the subscription.\n * @returns {Promise<torii.Subscription>} - A promise that resolves to a Torii subscription.\n *\n * @example\n * const subscription = await subscribeEntityQuery(client, query, schema, (response) => {\n *     if (response.error) {\n *         console.error(\"Error:\", response.error);\n *     } else {\n *         console.log(\"Data:\", response.data);\n *     }\n * }, { logging: true });\n */\nexport async function subscribeEntityQuery<T extends SchemaType>(\n    client: torii.ToriiClient,\n    query: SubscriptionQueryType<T>,\n    schema: T,\n    callback?: (response: {\n        data?: StandardizedQueryResult<T>;\n        error?: Error;\n    }) => void,\n    options?: { logging?: boolean }\n): Promise<torii.Subscription> {\n    if (options?.logging) {\n        console.log(\"Query:\", query);\n        console.log(\n            \"convertQueryToEntityKeyClauses:\",\n            convertQueryToEntityKeyClauses(query, schema)\n        );\n    }\n    return client.onEntityUpdated(\n        convertQueryToEntityKeyClauses(query, schema),\n        (entityId: string, entityData: any) => {\n            try {\n                if (callback) {\n                    const parsedData = parseEntities<T>({\n                        [entityId]: entityData,\n                    });\n                    if (options?.logging) {\n                        console.log(\n                            \"Converted query to entity key clauses:\",\n                            convertQueryToEntityKeyClauses(query, schema)\n                        );\n                        console.log(\"Parsed entity data:\", parsedData);\n                    }\n                    callback({ data: parsedData });\n                }\n            } catch (error) {\n                if (callback) {\n                    if (options?.logging) {\n                        console.error(\"Error parsing entity data:\", error);\n                    }\n                    callback({\n                        error:\n                            error instanceof Error\n                                ? error\n                                : new Error(String(error)),\n                    });\n                }\n            }\n        }\n    );\n}\n","import * as torii from \"@dojoengine/torii-client\";\n\nimport { convertQueryToEntityKeyClauses } from \"./convertQueryToEntityKeyClauses\";\nimport { parseEntities } from \"./parseEntities\";\nimport {\n    SchemaType,\n    StandardizedQueryResult,\n    SubscriptionQueryType,\n} from \"./types\";\n\n/**\n * Subscribes to event messages based on the provided query and invokes the callback with the updated data.\n *\n * @template T - The schema type.\n * @param {torii.ToriiClient} client - The Torii client instance.\n * @param {SubscriptionQueryType<T>} query - The subscription query to filter the events.\n * @param {T} schema - The schema type for the entities.\n * @param {(response: { data?: StandardizedQueryResult<T>; error?: Error }) => void} [callback] - The callback function to handle the response.\n * @param {{ logging?: boolean }} [options] - Optional settings for the subscription.\n * @returns {Promise<torii.Subscription>} - A promise that resolves to a Torii subscription.\n *\n * @example\n * const subscription = await subscribeEventQuery(client, query, schema, (response) => {\n *     if (response.error) {\n *         console.error(\"Error:\", response.error);\n *     } else {\n *         console.log(\"Data:\", response.data);\n *     }\n * }, { logging: true });\n */\nexport async function subscribeEventQuery<T extends SchemaType>(\n    client: torii.ToriiClient,\n    query: SubscriptionQueryType<T>,\n    schema: T,\n    callback?: (response: {\n        data?: StandardizedQueryResult<T>;\n        error?: Error;\n    }) => void,\n    options?: { logging?: boolean }\n): Promise<torii.Subscription> {\n    return client.onEventMessageUpdated(\n        convertQueryToEntityKeyClauses(query, schema),\n        true,\n        (entityId: string, entityData: any) => {\n            try {\n                if (callback) {\n                    const parsedData = parseEntities<T>({\n                        [entityId]: entityData,\n                    });\n                    if (options?.logging) {\n                        console.log(\"Parsed entity data:\", parsedData);\n                    }\n                    callback({ data: parsedData });\n                }\n            } catch (error) {\n                if (callback) {\n                    if (options?.logging) {\n                        console.error(\"Error parsing entity data:\", error);\n                    }\n                    callback({\n                        error:\n                            error instanceof Error\n                                ? error\n                                : new Error(String(error)),\n                    });\n                }\n            }\n        }\n    );\n}\n","import { writable, get, derived } from \"svelte/store\";\nimport {\n    produce,\n    produceWithPatches,\n    Draft,\n    Patch,\n    applyPatches,\n    WritableDraft,\n} from \"immer\";\nimport { ParsedEntity, SchemaType } from \"../types\";\n\n/**\n * Interface for a pending transaction, containing the transaction ID,\n * patches to apply, and inverse patches for reverting.\n */\ninterface PendingTransaction {\n    transactionId: string;\n    patches: Patch[];\n    inversePatches: Patch[];\n}\n\n/**\n * Interface representing the game state, including entities, pending transactions,\n * and methods for manipulating the state.\n */\ninterface GameState<T extends SchemaType> {\n    entities: Record<string, ParsedEntity<T>>;\n    pendingTransactions: Record<string, PendingTransaction>;\n}\n\n/**\n * Factory function to create a Svelte store based on a given SchemaType.\n *\n * @template T - The schema type.\n * @returns An object containing the Svelte store and methods to manipulate it.\n */\nexport function createDojoStore<T extends SchemaType>() {\n    // Define the initial state of the store.\n    const initialState: GameState<T> = {\n        entities: {},\n        pendingTransactions: {},\n    };\n\n    // Create a Svelte writable store with the initial state.\n    const store = writable<GameState<T>>(initialState);\n\n    // Destructure the subscribe, set, and update methods from the store.\n    const { subscribe, set, update } = store;\n\n    /**\n     * Sets multiple entities in the store.\n     *\n     * @param entities - An array of entities to set.\n     */\n    const setEntities = (entities: ParsedEntity<T>[]) => {\n        update((state) =>\n            produce(state, (draft: Draft<GameState<T>>) => {\n                entities.forEach((entity) => {\n                    draft.entities[entity.entityId] = entity as WritableDraft<\n                        ParsedEntity<T>\n                    >;\n                });\n            })\n        );\n    };\n\n    /**\n     * Updates a specific entity in the store.\n     *\n     * @param entity - The partial entity data to update.\n     */\n    const updateEntity = (entity: Partial<ParsedEntity<T>>) => {\n        update((state) =>\n            produce(state, (draft: Draft<GameState<T>>) => {\n                if (\n                    entity.entityId &&\n                    draft.entities[entity.entityId] &&\n                    entity.models\n                ) {\n                    const existingEntity = draft.entities[entity.entityId];\n\n                    // Merge existing models with the new models.\n                    const mergedModels = Object.assign(\n                        {},\n                        existingEntity.models\n                    );\n\n                    Object.entries(entity.models).forEach(\n                        ([namespace, namespaceModels]) => {\n                            const typedNamespace =\n                                namespace as keyof typeof mergedModels;\n                            if (!(typedNamespace in mergedModels)) {\n                                mergedModels[typedNamespace] = {} as any;\n                            }\n\n                            mergedModels[typedNamespace] = Object.assign(\n                                {},\n                                mergedModels[typedNamespace],\n                                namespaceModels\n                            );\n                        }\n                    );\n\n                    // Update the entity in the draft state.\n                    draft.entities[entity.entityId] = {\n                        ...existingEntity,\n                        ...entity,\n                        models: mergedModels,\n                    } as WritableDraft<ParsedEntity<T>>;\n                }\n            })\n        );\n    };\n\n    /**\n     * Applies an optimistic update to the store state.\n     *\n     * @param transactionId - The ID of the transaction.\n     * @param updateFn - A function that applies updates to the draft state.\n     */\n    const applyOptimisticUpdate = (\n        transactionId: string,\n        updateFn: (draft: Draft<GameState<T>>) => void\n    ) => {\n        const currentState = get(store);\n        const [nextState, patches, inversePatches] = produceWithPatches(\n            currentState,\n            (draft: Draft<GameState<T>>) => {\n                updateFn(draft);\n            }\n        );\n\n        set(nextState);\n\n        update((state) =>\n            produce(state, (draft: Draft<GameState<T>>) => {\n                draft.pendingTransactions[transactionId] = {\n                    transactionId,\n                    patches,\n                    inversePatches,\n                };\n            })\n        );\n    };\n\n    /**\n     * Reverts an optimistic update based on the transaction ID.\n     *\n     * @param transactionId - The ID of the transaction to revert.\n     */\n    const revertOptimisticUpdate = (transactionId: string) => {\n        const currentState = get(store);\n        const transaction = currentState.pendingTransactions[transactionId];\n        if (transaction) {\n            const newState = applyPatches(\n                currentState,\n                transaction.inversePatches\n            );\n            set(newState);\n\n            update((state) =>\n                produce(state, (draft: Draft<GameState<T>>) => {\n                    delete draft.pendingTransactions[transactionId];\n                })\n            );\n        }\n    };\n\n    /**\n     * Confirms a transaction by removing it from pending transactions.\n     *\n     * @param transactionId - The ID of the transaction to confirm.\n     */\n    const confirmTransaction = (transactionId: string) => {\n        update((state) =>\n            produce(state, (draft: Draft<GameState<T>>) => {\n                delete draft.pendingTransactions[transactionId];\n            })\n        );\n    };\n\n    /**\n     * Retrieves a specific entity from the store.\n     *\n     * @param entityId - The ID of the entity to retrieve.\n     * @returns The requested entity or undefined if not found.\n     */\n    const getEntity = (entityId: string): ParsedEntity<T> | undefined => {\n        const state = get(store);\n        return state.entities[entityId];\n    };\n\n    /**\n     * Retrieves all entities, optionally filtered by a predicate function.\n     *\n     * @param filter - An optional predicate function to filter entities.\n     * @returns An array of entities.\n     */\n    const getEntities = (\n        filter?: (entity: ParsedEntity<T>) => boolean\n    ): ParsedEntity<T>[] => {\n        const state = get(store);\n        const allEntities = Object.values(state.entities);\n        return filter ? allEntities.filter(filter) : allEntities;\n    };\n\n    /**\n     * Retrieves entities based on a specific model.\n     *\n     * @param namespace - The namespace of the model.\n     * @param model - The model key.\n     * @returns An array of entities matching the model.\n     */\n    const getEntitiesByModel = (\n        namespace: keyof T,\n        model: keyof T[keyof T]\n    ): ParsedEntity<T>[] => {\n        return getEntities((entity) => {\n            return !!entity.models[namespace]?.[model];\n        });\n    };\n\n    /**\n     * Subscribes to changes of a specific entity.\n     *\n     * @param entityId - The ID of the entity to subscribe to.\n     * @param listener - A callback function that receives the entity.\n     * @returns A function to unsubscribe from the entity updates.\n     */\n    const subscribeToEntity = (\n        entityId: string,\n        listener: (entity: ParsedEntity<T> | undefined) => void\n    ): (() => void) => {\n        // Create a derived store for the specific entity.\n        const entityStore = derived(\n            store,\n            ($store) => $store.entities[entityId]\n        );\n        return entityStore.subscribe(listener);\n    };\n\n    /**\n     * Waits for an entity to change based on a predicate function.\n     *\n     * @param entityId - The ID of the entity to monitor.\n     * @param predicate - A function that returns true when the desired condition is met.\n     * @param timeout - An optional timeout in milliseconds.\n     * @returns A promise that resolves with the entity or rejects on timeout.\n     */\n    const waitForEntityChange = (\n        entityId: string,\n        predicate: (entity: ParsedEntity<T> | undefined) => boolean,\n        timeout = 6000\n    ): Promise<ParsedEntity<T> | undefined> => {\n        return new Promise<ParsedEntity<T> | undefined>((resolve, reject) => {\n            const unsubscribe = subscribe((state) => {\n                const entity = state.entities[entityId];\n                if (predicate(entity)) {\n                    clearTimeout(timer);\n                    unsubscribe();\n                    resolve(entity);\n                }\n            });\n\n            const timer = setTimeout(() => {\n                unsubscribe();\n                reject(\n                    new Error(\n                        `waitForEntityChange: Timeout of ${timeout}ms exceeded`\n                    )\n                );\n            }, timeout);\n        });\n    };\n\n    // Return the store and methods for use in Svelte components.\n    return {\n        subscribe,\n        setEntities,\n        updateEntity,\n        applyOptimisticUpdate,\n        revertOptimisticUpdate,\n        confirmTransaction,\n        subscribeToEntity,\n        waitForEntityChange,\n        getEntity,\n        getEntities,\n        getEntitiesByModel,\n    };\n}\n","import { QueryType, SchemaType, SubscriptionQueryType } from \"./types\";\n\ntype FirstLevelKeys<ObjectType> = ObjectType extends object\n    ? keyof ObjectType & (string | number)\n    : never;\n\nexport class QueryBuilder<T extends SchemaType> {\n    namespaces: Map<string, Namespace<T>>;\n\n    constructor() {\n        this.namespaces = new Map<string, Namespace<T>>();\n    }\n\n    public namespace(\n        name: keyof T,\n        cb: (ns: Namespace<T>) => void\n    ): Namespace<T> {\n        const ns = new Namespace(this);\n        this.namespaces.set(name as string, ns);\n        cb(ns);\n        return ns;\n    }\n\n    public build(): SubscriptionQueryType<T> {\n        const qt: Record<\n            string,\n            Record<\n                string,\n                { $: { where: Record<string, Record<string, any>> } }\n            >\n        > = {};\n        for (const [ns, namespace] of this.namespaces) {\n            qt[ns] = {};\n            for (const [entity, entityObj] of namespace.entities) {\n                const constraints: Record<string, Record<string, any>> = {};\n                for (const [field, constraint] of entityObj.constraints) {\n                    constraints[field] = {\n                        [`${constraint.operator}`]: constraint.value,\n                    };\n                }\n                qt[ns][entity] = {\n                    $: {\n                        where: {\n                            ...(qt[ns]?.[entity]?.$?.where ?? {}),\n                            ...constraints,\n                        },\n                    },\n                };\n            }\n        }\n        return qt as SubscriptionQueryType<T>;\n    }\n}\n\nclass Namespace<T extends SchemaType> {\n    entities: Map<string, QueryEntity<T>>;\n\n    constructor(private parent: QueryBuilder<T>) {\n        this.entities = new Map<string, QueryEntity<T>>();\n    }\n\n    public entity(\n        name: FirstLevelKeys<T[keyof T & string]>,\n        cb: (entity: QueryEntity<T>) => void\n    ): QueryEntity<T> {\n        const entity = new QueryEntity(this);\n        this.entities.set(name as string, entity);\n        cb(entity);\n        return entity;\n    }\n\n    public namespace(ns: string, cb: (ns: Namespace<T>) => void): Namespace<T> {\n        return this.parent.namespace(ns, cb);\n    }\n\n    public build(): SubscriptionQueryType<T> {\n        return this.parent.build();\n    }\n}\n\nclass QueryEntity<T extends SchemaType> {\n    constraints: Map<string, Constraint>;\n\n    constructor(private parent: Namespace<T>) {\n        this.constraints = new Map<string, Constraint>();\n    }\n    public entity(\n        name: FirstLevelKeys<T[keyof T & string]>,\n        cb: (entity: QueryEntity<T>) => void\n    ): QueryEntity<T> {\n        return this.parent.entity(name, cb);\n    }\n\n    public is(\n        field: FirstLevelKeys<T[keyof T & string][keyof T[keyof T & string]]>,\n        value: any\n    ): QueryEntity<T> {\n        return this.addConstraint(field, value, Operator.is);\n    }\n\n    public eq(\n        field: FirstLevelKeys<T[keyof T & string][keyof T[keyof T & string]]>,\n        value: any\n    ): QueryEntity<T> {\n        return this.addConstraint(field, value, Operator.eq);\n    }\n\n    public neq(\n        field: FirstLevelKeys<T[keyof T & string][keyof T[keyof T & string]]>,\n        value: any\n    ): QueryEntity<T> {\n        return this.addConstraint(field, value, Operator.neq);\n    }\n\n    public gt(\n        field: FirstLevelKeys<T[keyof T & string][keyof T[keyof T & string]]>,\n        value: any\n    ): QueryEntity<T> {\n        return this.addConstraint(field, value, Operator.gt);\n    }\n\n    public gte(\n        field: FirstLevelKeys<T[keyof T & string][keyof T[keyof T & string]]>,\n        value: any\n    ): QueryEntity<T> {\n        return this.addConstraint(field, value, Operator.gte);\n    }\n\n    public lt(\n        field: FirstLevelKeys<T[keyof T & string][keyof T[keyof T & string]]>,\n        value: any\n    ): QueryEntity<T> {\n        return this.addConstraint(field, value, Operator.lt);\n    }\n\n    public lte(\n        field: FirstLevelKeys<T[keyof T & string][keyof T[keyof T & string]]>,\n        value: any\n    ): QueryEntity<T> {\n        return this.addConstraint(field, value, Operator.lte);\n    }\n\n    private addConstraint(\n        field: FirstLevelKeys<T[keyof T & string][keyof T[keyof T & string]]>,\n        value: any,\n        op: Operator\n    ): QueryEntity<T> {\n        this.constraints.set(field as string, new Constraint(op, value));\n        return this;\n    }\n\n    public build(): QueryType<T> {\n        return this.parent.build();\n    }\n}\n\nclass Constraint {\n    constructor(\n        private _operator: Operator,\n        private _value: any\n    ) {}\n\n    get operator(): string {\n        return this._operator.toString();\n    }\n\n    get value(): any {\n        return this._value;\n    }\n}\n\nenum Operator {\n    is = \"$is\",\n    eq = \"$eq\",\n    neq = \"$neq\",\n    gt = \"$gt\",\n    gte = \"$gte\",\n    lt = \"$lt\",\n    lte = \"$lte\",\n}\n"],"mappings":"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","names":["torii","torii","convertQueryToEntityKeyClauses","query","schema","clauses","entityIds","namespaces","convertQueryToKeysClause","namespace","models","model","value","namespaceModel","clause","createClause","whereOptions","modelSchema","createClauseFromWhere","fieldOrder","keys","field","condition","index","convertQueryToClause","query","schema","clauses","namespace","models","modelClauses","processModels","model","modelData","namespaceModel","conditions","whereClause","member","memberConditions","isClauses","convertQueryToEntityKeyClauses","$is","remainingConditions","clause","buildWhereClause","where","logicalOperators","logicalKey","key","operator","subClauses","condition","memberClauses","memberValue","memberLogicalKey","nestedClauses","op","val","convertOperator","convertToPrimitive","value","parseEntities","entities","options","result","entityId","entityData","parsedEntity","modelName","schemaKey","modelKey","parseStruct","parseValue","value","struct","entries","key","getEntities","client","query","schema","callback","limit","offset","options","clause","convertQueryToClause","cursor","continueFetching","allEntities","toriiQuery","entities","parsedEntities","parseEntities","error","getEventMessages","client","query","schema","callback","limit","offset","options","clause","convertQueryToClause","cursor","continueFetching","allEntities","toriiQuery","entities","parsedEntities","parseEntities","error","subscribeEntityQuery","client","query","schema","callback","options","convertQueryToEntityKeyClauses","entityId","entityData","parsedData","parseEntities","error","subscribeEventQuery","client","query","schema","callback","options","convertQueryToEntityKeyClauses","entityId","entityData","parsedData","parseEntities","error","writable","get","derived","produce","produceWithPatches","applyPatches","createDojoStore","store","subscribe","set","update","setEntities","entities","state","draft","entity","updateEntity","existingEntity","mergedModels","namespace","namespaceModels","typedNamespace","applyOptimisticUpdate","transactionId","updateFn","currentState","nextState","patches","inversePatches","revertOptimisticUpdate","transaction","newState","confirmTransaction","getEntity","entityId","getEntities","filter","allEntities","listener","$store","predicate","timeout","resolve","reject","unsubscribe","timer","model","QueryBuilder","name","cb","ns","Namespace","qt","namespace","entity","entityObj","constraints","field","constraint","parent","QueryEntity","value","op","Constraint","_operator","_value","createClient","config","init","options","schema","client","query","callback","subscribeEntityQuery","subscribeEventQuery","limit","offset","getEntities","getEventMessages","primaryType","message","domain","key","data","account","isSessionSignature","signature","dataString","error","contract_addresses","account_addresses"]}